<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise</title>
</head>

<body>
    <script>
        /* const promise1 = new Promise((resolve, reject) => {
            console.log('promise1')
        })
        console.log('1', promise1); */

        /* const promise = new Promise((resolve, reject) => {
            console.log(1);
            resolve('success')
            console.log(2);
        });
        promise.then(() => {
            console.log(3);
        });
        console.log(4); */

        /* const promise1 = new Promise((resolve, reject) => {
            console.log('promise1')
            resolve('resolve1')
        })
        const promise2 = promise1.then(res => {
            console.log(res)
        })
        console.log('1', promise1);
        console.log('2', promise2); */

        /* const fn = () => (new Promise((resolve, reject) => {
            console.log(1);
            resolve('success')
        }))
        fn().then(res => {
            console.log(res)
        })
        console.log('start') */

        /* const fn = () =>
            new Promise((resolve, reject) => {
                console.log(1);
                resolve("success");
            });
        console.log("start");
        fn().then(res => {
            console.log(res);
        }); */

        /* console.log('start')
        setTimeout(() => {
            console.log('time')
        })
        Promise.resolve().then(() => {
            console.log('resolve')
        })
        console.log('end') */

        /* const promise = new Promise((resolve, reject) => {
            console.log(1);
            setTimeout(() => {
                console.log("timerStart");
                resolve("success");
                console.log("timerEnd");
            }, 0);
            console.log(2);
        });
        promise.then((res) => {
            console.log(res);
        });
        console.log(4); */

        /* setTimeout(() => {
            console.log('timer1');
            setTimeout(() => {
                console.log('timer3')
            }, 0)
        }, 0)
        setTimeout(() => {
            console.log('timer2')
        }, 0)
        console.log('start') */

        /* Promise.resolve().then(() => {
            console.log('promise1');
            const timer2 = setTimeout(() => {
                console.log('timer2')
            }, 0)
        });
        const timer1 = setTimeout(() => {
            console.log('timer1')
            Promise.resolve().then(() => {
                console.log('promise2')
            })
        }, 0)
        console.log('start'); */

        /* const promise1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('success')
            }, 1000)
        })
        const promise2 = promise1.then(() => {
            throw new Error('error!!!')
        })
        console.log('promise1', promise1)
        console.log('promise2', promise2)
        setTimeout(() => {
            console.log('promise1', promise1)
            console.log('promise2', promise2)
        }, 2000) */

        /* const promise1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve("success");
                console.log("timer1");
            }, 1000);
            console.log("promise1里的内容");
        });
        const promise2 = promise1.then(() => {
            throw new Error("error!!!");
        });
        console.log("promise1", promise1);
        console.log("promise2", promise2);
        setTimeout(() => {
            console.log("timer2");
            console.log("promise1", promise1);
            console.log("promise2", promise2);
        }, 2000); */


        /* const promise = new Promise((resolve, reject) => {
            resolve("success1");
            reject("error");
            resolve("success2");
        });
        promise
            .then(res => {
                console.log("then: ", res);
            })
            .catch(err => {
                console.log("catch: ", err);
            }) */
        /* const promise = new Promise((resolve, reject) => {
            reject("error");
        });
        promise.then(res => {
            console.log("then1: ", res);
        })
            .then(res => {
                console.log("then2: ", res);
            }).catch(err => {
                console.log("catch: ", err);
            }).then(res => {
                console.log("then3: ", res);
            }) */

        /* Promise.resolve(1)
            .then(res => {
                console.log(res);
                return 2;
            })
            .catch(err => {
                return 3;
            })
            .then(res => {
                console.log(res);
            }); */

        /* Promise.reject(1)
            .then(res => {
                console.log(res);
                return 2;
            })
            .catch(err => {
                console.log(err);
                return 3
            })
            .then(res => {
                console.log(res);
            }); */

        /* const promise = new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log('timer')
                resolve('success')
            }, 1000)
        })
        const start = Date.now();
        promise.then(res => {
            console.log(res, Date.now() - start)
        })
        promise.then(res => {
            console.log(res, Date.now() - start)
        }) */

        /* Promise.resolve().then(() => {
            return new Error('error!!!')
        }).then(res => {
            console.log("then: ", res)
        }).catch(err => {
            console.log("catch: ", err)
        }) */

        // 不能循环引用
        /* const promise = Promise.resolve().then(() => {
            return promise;
        })
        promise.catch(err => {
            console.log(err);
        }) */

        /* Promise.resolve(1)
            .then(2)
            .then(Promise.resolve(3))
            .then(console.log) */

        /* Promise.resolve([1,2,3,4])
        .then(2,err => {
            console.log('p1 失败', err);
        })
        .then(res => {
            console.log('p2 成功', res);
        }) */

        /* Promise.reject('err!!!')
            .then((res) => {
                console.log('success', res)
            }, (err) => {
                console.log('error', err)
            }).catch(err => {
                console.log('catch', err)
            }) */

        /* Promise.reject('error!!!')
            .then((res) => {
                console.log('success', res)
            }).catch(err => {
                console.log('catch', err)
            }) */

        /* Promise.resolve()
            .then(function success(res) {
                throw new Error('error!!!')
            }, function fail1(err) {
                console.log('fail1', err)
            }).catch(function fail2(err) {
                console.log('fail2', err)
            }) */

        /* Promise.resolve('1')
                    .then(res => {
                        console.log(res)
                    })
                    .finally(() => {
                        console.log('finally')
                        setTimeout(() => {
                            console.log('f1');
                        })
                    })
                Promise.resolve('2')
                    .finally(() => {
                        console.log('finally2')
                        setTimeout(() => {
                            console.log('f2');
                        })
                        return 123
                    })
                    .finally(() => {
                        console.log('finally3');
                    })
                    .then(res => {
                        console.log(res)
                    }) */
        /* Promise.resolve('1')
            .finally(() => {
                console.log('finally1')
                // throw new Error('我是finally中抛出的异常')
                return new Error('error')
            })
            .then(res => {
                console.log('finally后面的then函数', res)
            })
            .catch(err => {
                console.log('捕获错误', err)
            }) */
        /* function promise1() {
            let p = new Promise((resolve) => {
                console.log('promise1');
                resolve('1')
            })
            return p;
        }
        function promise2() {
            return new Promise((resolve, reject) => {
                reject('error')
            })
        }
        promise1()
            .then(res => console.log(res))
            .catch(err => console.log(err))
            .finally(() => console.log('finally1'))

        promise2()
            .then(res => console.log(res))
            .catch(err => console.log(err))
            .finally(() => console.log('finally2')) */

        /* function promise1() {
            let p = new Promise((resolve) => {
                console.log('promise1');
                resolve('1')
            })
            return p;
        }
        function promise2() {
            return new Promise((resolve, reject) => {
                reject('error')
            })
        }
        promise1()
            .then(res => console.log(res))
            .catch(err => console.log(err))
            .then(() => console.log('finally1'))

        promise2()
            .then(res => console.log(res))
            .catch(err => console.log(err))
            .then(() => console.log('finally2')) */



        /*
        function runAsync(x) {
            const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
            return p
        }
        function runAsync(x) {
            return new Promise(resolve => {
                return setTimeout(() => {
                    return resolve(x,console.log(x))
                }, 1000)
            })
        }
        Promise.all([runAsync(1), runAsync(2), runAsync(3)])
            .then(res => console.log(res)) */

        /* // function runAsync(x) {
        //     const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
        //     return p
        // }
        function runAsync(x) {
            return new Promise(resolve => {
                return setTimeout(() => {
                    return resolve(x, console.log(x))
                }, 1000)
            })
        }
        // function runReject(x) {
        //     const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
        //     return p
        // }
        function runReject(x) {
            return new Promise((resolve, reject) => {
                return setTimeout(() => {
                    return reject(`Error: ${x}`, console.log(x))
                }, 1000 * x)
            })
        }
        Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
            .then(res => console.log(res, 'res'),err => console.log(err,'err2'))
            .catch(err => console.log(err, 'err')) */

        //
        /* function runAsync(x) {
            return new Promise(resolve => {
                return setTimeout(() => {
                    return resolve(x, console.log(x))
                }, 1000)
            })
        }
        Promise.race([runAsync(1), runAsync(2), runAsync(3)])
            .then(res => console.log('result: ', res))
            .catch(err => console.log(err)) */

        /* function runAsync(x) {
            const p = new Promise(r =>
                setTimeout(() => r(x, console.log(x)), 1000)
            );
            return p;
        }
        function runReject(x) {
            const p = new Promise((res, rej) =>
                setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x)
            );
            return p;
        }
        Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])
            .then(res => console.log("result: ", res))
            .catch(err => console.log(err)); */

        /* async function async1() {
            console.log("async1 start");
            await async2();
            console.log("async1 end");
        }
        async function async2() {
            console.log("async2");
        }
        async1();
        console.log('start') */

        /* async function async1() {
            console.log("async1 start");
            new Promise(resolve => {
                console.log('promise')
            })
            console.log("async1 end");
        }
        async1();
        console.log("start") */

        /* async function async1() {
            console.log("async1 start");
            await async2();
            console.log("async1 end");
        }
        async function async2() {
            setTimeout(() => {
                console.log('timer')
            }, 0)
            console.log("async2");
        }
        async1();
        console.log("start") */

        /* async function async1() {
            console.log("async1 start");
            await async2();
            console.log("async1 end");
            setTimeout(() => {
                console.log('timer1')
            }, 0)
        }
        async function async2() {
            setTimeout(() => {
                console.log('timer2')
            }, 0)
            console.log("async2");
        }
        async1();
        setTimeout(() => {
            console.log('timer3')
        }, 0)
        console.log("start") */

        /* async function fn() {
            // await new Promise(resolve => {
            //     console.log(2)
            // })
            return 123
        }
        fn().then(res => console.log(res))
        console.log('------'); */

        /* async function async1() {
            console.log(1);
            await new Promise((resolve, reject) => {
                console.log(2)
                // resolve(8)
                // reject(8)
            })
            console.log(3);
            return 4
        }
        console.log(5)
        async1().then(res => console.log(res,'res'))
        console.log(6) */

        /* console.log('---------');

        console.log(5);
        new Promise((resolve) => {
            console.log(1);
            new Promise((resolve,reject) => {
                console.log(2);
                // reject('err')
            })
            .then(() => {
                console.log(3);
                return 4
            })
        })
        console.log(6); */

        /* async function async1() {
            console.log(1);
            await new Promise(resolve => {
                console.log(2)
                resolve(3)
            })
            .then(res => console.log(res))
            console.log(4);
            return 5
        }
        console.log(6)
        async1().then(res => console.log(res))
        console.log(7) */

        /* async function async1() {
            console.log(1);
            await new Promise(resolve => {
                console.log(2)
                resolve(3)
            })
            console.log(4);
            return 5
        }
        console.log(6)
        async1().then(res => {
            console.log(res)
        })
        new Promise(resolve => {
            console.log(7)
            setTimeout(() => {
                console.log(8)
            })
        }) */

        /* async function async1() {
            console.log(1);
            await async2();
            console.log(2);
        }

        async function async2() {
            console.log(3);
        }

        console.log(4);

        setTimeout(function () {
            console.log(5);
        }, 0);

        async1();

        new Promise(function (resolve) {
            console.log(6);
            resolve();
        }).then(function () {
            console.log(7);
        });
        console.log(8) */

        /* async function testSomething() {
            console.log(1);
            return 2;
        }

        async function testAsync() {
            console.log(3);
            return Promise.resolve(4);
        }

        async function test() {
            console.log(5);
            const v1 = await testSomething();
            console.log(v1);
            const v2 = await testAsync();
            console.log(v2);
            console.log(v1, v2);
        }

        test();

        var promise = new Promise(resolve => {
            console.log(6);
            resolve(7);
        });
        promise.then(val => console.log(val));

        console.log(8); */

        /* async function async1() {
            await async2();
            console.log('async1');
            return 'async1 success'
        }
        async function async2() {
            return new Promise((resolve, reject) => {
                console.log('async2')
                reject('error')
            })
        }
        async1().then(res => console.log(res)) */

        /* async function async1() {
            try {
                await Promise.reject(1)
            } catch (e) {
                console.log(e)
            }
            console.log(2);
            return Promise.resolve(3)
        }
        async1().then(res => console.log(res))
        console.log(4) */

        /* async function async1() {
            // try {
            //   await Promise.reject('error!!!')
            // } catch(e) {
            //   console.log(e)
            // }
            await Promise.reject(1)
                .catch(e => console.log(e))
            console.log(2);
            return Promise.resolve(3)
        }
        async1().then(res => console.log(res))
        console.log(4) */

        /* const first = () => (new Promise((resolve, reject) => {
            console.log(3);
            let p = new Promise((resolve, reject) => {
                console.log(7);
                setTimeout(() => {
                    console.log(5);
                    resolve(6);
                    console.log(p)
                }, 0)
                resolve(1);
            });
            resolve(2);
            p.then((arg) => {
                console.log(arg);
            });
        }));
        first().then((arg) => {
            console.log(arg);
        });
        console.log(4); */

        /* const async1 = async () => {
            console.log(1);
            setTimeout(() => {
                console.log(2)
            }, 2000)
            await new Promise(resolve => {
                console.log(3)
            })
            console.log(4)
            return 5
        }
        console.log(6);
        async1().then(res => console.log(res));
        console.log(7);
        Promise.resolve(8)
            .then(9)
            .then(Promise.resolve(10))
            .catch(11)
            .then(res => console.log(res))
        setTimeout(() => {
            console.log(12)
        }, 1000) */

        /* const async1 = async () => {
            console.log('async1');
            setTimeout(() => {
                console.log('timer1')
            }, 2000)
            await new Promise(resolve => {
                console.log('promise1')
            })
            console.log('async1 end')
            return 'async1 success'
        }
        console.log('script start');
        async1().then(res => console.log(res));
        console.log('script end');
        Promise.resolve(1)
            .then(2)
            .then(Promise.resolve(3))
            .catch(4)
            .then(res => console.log(res))
        setTimeout(() => {
            console.log('timer2')
        }, 1000) */

        /* const p1 = new Promise(resolve => {
            setTimeout(() => {
                console.log(p1); // 这里的p1是返回的链式调用的 promise对象, 所以打印的结果是成功状态返回值为 undefined
            },0)
            resolve(123)
        }).then(res => {
            console.log(res);
        })


        const p2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log(p2)
            }, 0)
            resolve(1);
        }); */

        // 使用Promise实现每隔1秒输出1,2,3

        /*
        分析代码过程：
        每一次都是一个 微任务和宏任务
        */
        /* const arr = [1, 2, 3]
        const a = arr.reduce((prev, cur) => {
            // 返回一个新的 Promise 对象 给 prev
            return prev.then(() => {
                // 需要改变 prev.then 的状态, 将成功的结果返回给 prev.then 得到一个新的 promise对象
                return new Promise(resolve => {
                    setTimeout(() => {
                        console.log(cur);
                        resolve(cur)
                    }, 1000)
                })
            })
        }, Promise.resolve())
 */
        // const a = arr.reduce((prev, cur) => {
        //     console.log(prev, cur);
        //     return prev = cur
        // })
        // console.log(a);

        const arr = [1, 2, 3]
        // arr.reduce((p, x) => p.then(() => new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve())
        /* arr.reduce((prev, cur) => {
            return prev.then(() => {
                return new Promise(resolve => {
                    return setTimeout(() => {
                        return resolve(console.log(cur))
                    }, 1000)
                })
            })
        }, Promise.resolve()) */

        // 伪代码
        /* Promise.resolve()
            .then(() => {
                 return new Promise(r => {
                    setTimeout(() => {
                        r(console.log(1))
                    }, 1000)
                })
            })
            .then(r => {
                return new Promise(r => {
                    setTimeout(() => {
                        r(console.log(2))
                    }, 1000)
                })
            })
            .then(r => {
                return new Promise(r => {
                    setTimeout(() => {
                        r(console.log(3))
                    }, 1000)
                })
            }) */



        // const result = arr.reduce((p, x) => p.then(new Promise(r => setTimeout(() => r(console.log(x)), 1000))), Promise.resolve());

        /* arr.reduce((prev, cur) => {
            return prev.then(
                new Promise(resolve => {
                    return setTimeout(() => {
                        resolve(console.log(cur))
                    }, 1000)
                })
            )
        }, Promise.resolve()) */

        // 伪代码 发生透传了

        /* Promise.resolve()
            .then(new Promise(r => {
                setTimeout(() => {
                    r(console.log(1))
                }, 1000)
            }))
            .then(new Promise(r => {
                setTimeout(() => {
                    r(console.log(2))
                }, 1000)
            }))
            .then(new Promise(r => {
                setTimeout(() => {
                    r(console.log(3))
                }, 1000)
            })) */


        // const p = Promise.resolve(1).then(console.log('我不关心结果'))
        // console.log(p)
        // p.then((res) => console.log(res))

        /* function red() {
            console.log('red');

        }
        function green() {
            console.log('green');
        }
        function yellow() {
            console.log('yellow');
        }

        function repeatLight(cb, timer) {
            return new Promise(resolve => {
                setTimeout(() => resolve(cb()), timer)
            })
        }

        function step() {
            Promise.resolve()
                .then(() => repeatLight(red, 3000))
                .then(() => repeatLight(green, 2000))
                .then(() => repeatLight(yellow, 1000))
                .then(() => step())
        }
        // step() */

        /* const time = (timer) => {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve()
                }, timer)
            })
        }
        const ajax1 = () => time(2000).then(() => {
            console.log(1);
            return 1
        })
        const ajax2 = () => time(1000).then(() => {
            console.log(2);
            return 2
        })
        const ajax3 = () => time(1000).then(() => {
            console.log(3);
            return 3
        })

        function mergePromise(arr) {
            // 在这里写代码
            const data = [] // 初始化 data 用来保存所有的异步任务
            return arr.reduce((prev, cur) => {
                return prev.then(cur).then(res => {
                    data.push(res)
                    return data
                })
            }, Promise.resolve())
        }


        mergePromise([ajax1, ajax2, ajax3])
            .then(data => {
                console.log("done");
                console.log(data); // data 为 [1, 2, 3]
            }); */

        // 要求分别输出
        // 1
        // 2
        // 3
        // done
        // [1, 2, 3]

        function ajax(url) {
            return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest()
                xhr.open('GET', url)
                xhr.responseType = 'json'
                xhr.onload = function () {
                    if (this.status === 200) {
                        resolve(this.response)
                    } else {
                        reject(new Error(this.statusText))
                    }
                }
                xhr.send(null)
            })
        }

        function* main() {
            try {
                const users = yield ajax('./api/user.json')
                console.log(users, 'users');

                const posts = yield ajax('./api/posts.json')
                console.log(posts, 'posts');
            } catch (error) {
                console.log(error);
            }
        }

        /* const g = main()
        // const result = g.next()
        // console.log(result);
        // result.value.then(data => {
        //     g.next(data)
        // })

        function handlerResult(result) {
            if (result.done) return
            result.value.then(data => {
                handlerResult(g.next(data))
            }, error => {
                g.throw(error)
            })
        }

        handlerResult(g.next()) */

        function co(generator) {
            const g = generator()

            function handlerResult(result) {
                if (result.done) return
                result.value.then(data => {
                    handlerResult(g.next(data))
                }, error => {
                    g.throw(error)
                })
            }

            handlerResult(g.next())
        }

        co(main)







    </script>
</body>

</html>